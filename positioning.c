/*
 This program approaches the IR sensor until it is at an appropriate distance away to drop the ball. It signals that it is too far by turning on a red light on the breadboard, too close by flashing the red light, and when at the appropriate distance, the red light turns off.
 */
//Configure the Sensors, button, and motors
#pragma config(Sensor, in1,    irsignal,       sensorReflection)
#pragma config(Sensor, dgtl1,  button,         sensorTouch)
#pragma config(Sensor, dgtl3,  input,          sensorSONAR_cm)
#pragma config(Sensor, dgtl5,  redlight,       sensorLEDtoVCC)
#pragma config(Motor,  port1,           RightMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           LeftMotor,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//function to determine if the IR sensor is detecting the target, returns true if we are, false if not
	bool detection(){
		//initialize 2 variables for the values recorded by IR sensor
		int min = SensorValue[irsignal];
		int max = SensorValue[irsignal];

		/*since the value read by the IR sensor varies even when it's not detecting the target,
		and it varies more when we sense the target, we need to find when the there is more variance.
		To do this, we go through a quick loop (0.05 * 5 seconds) and retrieve the maximum and minimum read values during the 5 increments of the loop.
		If these values have a variance past 80 (number determined through trial and error), we are detecting the target and should return true.
		If not, we are not detecting the target, and the function returns false
		*/
		int i = 0;
		while( i<5 ){
			if (SensorValue[irsignal] < min) {
				min = SensorValue[irsignal];
			}else if (SensorValue[irsignal] > max) {
				max = SensorValue[irsignal];
			}
			wait1Msec(50);
			i++;
		}

		//difference between max and min is the variance
		if ( (max-min)>80 ){
			return true;
		}else{
			return false;
		}
}

task main(){
		while(true){
			//if the target is straight ahead and the appropriate distance away, signal by turning off the red light
			//note: in the final test, this is where we would drop the ball
			if( detection() && SensorValue(input)<=10 && SensorValue(input)>=5 ){
				SensorValue(redlight) = 0;
			//for too far, keep red light on
			}else if( detection() && SensorValue(input)>10){
				SensorValue(redlight) = 1;
			}
			//now if these are both not true, then must be too close. In this case, blink the led until it is no longer too close
			else{
				while(detection() && SensorValue(input)<5){
					SensorValue(redlight) = 0;
					wait1Msec(500);
					SensorValue(redlight) = 1;
					wait1Msec(500);
				}
		}
		}

}
